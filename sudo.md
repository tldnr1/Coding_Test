## Index
* 공통사항
* 기본 구현 (자료구조, 완전 탐색, 시뮬레이션)
* 인덱스, 효율적 탐색 (정렬, 이분 탐색, 투 포인터 & 슬라이딩 윈도우)
* 그래프, 상태 트리 탐색 (재귀&백트래킹, DFS / BFS)
* 최적화, 모델링 (그리디, DP, 최단경로)


---

## 공통 사항
1. 제약 조건 확인: N의 크기는? (시간 복잡도 결정: O(N), O(NlogN) 등)
2. 문제 유형 추론: 최단거리? -> BFS/다익스트라, 경우의 수? -> DP/백트래킹
3. 자료구조 선택: fifo? -> Queue, 중복제거? -> Set/Hash

---

## 1. 기본 구현
무식하게라도 정답을 도출하는 구현력을 기르는 단계

* 구성:
    - Python 문법, collections, heapq
    - 자료구조: stack, queue, deque, hash(dict), priorityQueue
    - 브루트포스: 완전 탐색, 시뮬레이션

* 묶은 이유:
    - 특정 자료구조에 데이터를 넣고 빼며 조건을 검사하는 과정
    - 시간 복잡도는 자료구조를 활용하며, 문제의 요구사항을 정확하게 코드로 옮겨야 함

* 학습 목표:
    - 시간 복잡도를 고려하지 않고, 문제의 요구사항을 정확하게 코드로 옮기기


---

## 2. 인덱스, 효율적 탐색
데이터가 정렬되어 있거나 선형(리스트)일 때, 모든 것을 다 보지 않고 효율적으로 답을 찾는 기술

* 구성:
    - 정렬: 정렬의 개념 및 커스텀 정렬(by lambda)
    - 이분 탐색: 파라메트릭 서치
    - 투 포인터 & 슬라이딩 윈도우: 연속된 데이터 O(N) 처리

* 묶은 이유:
    - `이분 탐색`은 반드시 `정렬`된 상태를 전제로 함
    - `투 포인터`와 `슬라이딩 윈도우`는 이중 반복문 O(N^2)를 한 번의 스캔 O(N)으로 줄여주는 기술로, `이분 탐색` O(NlogN)과 함께 시간 복잡도를 줄이는 인덱스 관리 기술임

* 학습 목표:
    - O(N^2)에서 시간 초과가 나는 문제를 최적화 하기기


---

## 3. 그래프, 상태 트리 탐색
데이터가 선형이 아니라 얽힌 경우, 혹은 가능한 모든 경우의 수를 가지치기하며 찾아야 할 때 사용하는 그룹. **가장 핵심이 되는 파트**

* 구성:
    - 재귀(Recursion) & 백트래킹: 순열, 조합, N-Queen
    - DFS / BFS: 그래프 탐색, 미로 찾기, 연결 요소

* 묶은 이유:
    - DFS의 구현 원리가 재귀임
    - 백트래킹은 DFS/재귀를 하다가 "이 길은 아닌가봐" 하고 되돌아오는 최적화 과정!
    - 결국 '모든 상태 공간을 어떻게 빠짐없이, 중복 없이 방문할 것인가' 에 대한 하나의 큰 주제라고 생각하기

* 학습 목표:
    - 재귀 함수의 흐름을 머릿속으로 그리거나 스택/큐를 활용해 비선형 구조를 자유롭게 탐색하는 능력


---

## 4. 최적화, 모델링
앞선 단계들은 '찾는 과정'이 중요했다면, 이 단계는 '점화식'이나 '그리디한 선택' 같은 `수학적 규칙`을 발견하는 것이 중요함

* 구성:
    - 그리디
    - 동적 계획법(DP): Memoization, 점화식, Knapsack, LCS
    - 최단 경로: 다익스트라(Dijkstra), 플로이드-워셜

* 묶은 이유:
    - DP와 그리디 모두 `최적의 해`를 구하는 방법론임 (**그리디는 현재의 최선, DP는 과거의 결과를 이용한 전체의 최선**)
    - 다익스트라 알고리즘은 사실상 그리디와 DP가 결합된 형태
        - 그리디: 가장 가까운 노드 선택
        - DP: 거리 갱신 == D[i] = min(D[i], D[k] + W)
    - 우선순위 큐가 여기서 다익스트라 구현의 핵심 도구로 사용됨

* 학습 목표:
    - 문제를 작은 단위로 쪼개어 수식(점화식)을 세우거나, 최적해를 보장하는 규칙성을 찾아내는 통찰력 훈련하기